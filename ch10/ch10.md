## Greedy Algorithm

- "Take what you can get now" strategy is the source of the name for this class of algorithm
- Virtually all scheduling problems are either NP-complete or are solvable by a greedy algorithm

### Huffman Codes

- If the characters are placed only at the leaves, any sequence of bits can always be decoded unambiguously
- Such an encoding is known as **prefix code**
- The encoding information must be transmitted at the start of the compressed file, since otherwise it will be impossible to decode
- This is a two-pass algorithm, the first pass collects the frequency data and the second pass does the encoding
- If we maintain the trees in a priority queue, ordered by weight, then the running time is `O(ClogC)`, where the `C` is the number of characters

### Approximate Bin Packing

#### Online Algorithm

- There are inputs that force any online bin-packing algorithm to use at least 4/3 the optimal number of bins
- **Next Fit**: When processing any items, we check to see whether it fits in the same bin as the last item. It it does, it is placed there; otherwise, a new bin is created
  - Let `M` be the optimal number of bins required to pack a list `I` of items. Then next fit never uses more than `2M` bins
- **First Fit**: Scan the bins in order and place the new item in the first bin that is large enough to hold it
  - Let `M` be the optimal number of bins required to pack a list `I` of items. Then next fit never uses more than `(17/10)M + 7/10` bins
- **Best Fit**: Instead of placing a new item in the first spot that is found, it is placed in the tightest spot among all bins
  - Let `M` be the optimal number of bins required to pack a list `I` of items. Then next fit never uses more than `(17/10)M` bins